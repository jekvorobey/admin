# Frontend обитель

## Начало работы

Должны быть установлены глобально:

1. node.js: https://nodejs.org/en/
2. yarn: https://yarnpkg.com/en/

Не забывайте обновлять их до последней версии, чтобы не было проблем с совместимостью и производительностью.

Подтягиваем зависимости:

```bash
yarn install
```

## Пакетный менеджер

На проекте используется пакетный менеджер **yarn** - все зависимости ставятся через него, и сохраняются в package.json. Файл yarn.lock лежит в репозитории и хранит информацию по загружаемым пакетам.

Зависимости, используемые исключительно при разработке, т.е. всё, что относится к dev-среде, например инструменты для сборки, сохраняются в devDependencies. devDependencies не попадают в production, так что их количество и размер не играет роли (даже чем больше, тем вы круче, как разраб). В dependencies же напротив прописываются зависимости, идущие в production - это, к примеру, библиотеки для компонентов страницы. Соответственно чем их меньше, тем лучше.

Установка внешнего модуля с сохранением в dependencies:

```bash
yarn add <имя модуля>
```

Установка внешнего модуля с сохранением в devDependencies:

```bash
yarn add -D <имя модуля>
```

## Работа с проектом

Запуск команд осуществляется через npm-скрипты. Список скриптов определяется в package.json в поле scripts. Для запуска скрипта использовать синтаксис:

```bash
yarn <имя скрипта>
```

Список скриптов:

1. **dev**. Запускает development-сборку и стартует сервер.
1. **dev-build**. Запускает development-сборку. Доступен параметр **--watch**. 
1. **prod**. Запускает production-сборку. Доступен параметр **--watch**.
1. **analyze**. Выполняет production-сборку и запускает Webpack Bundle Analyzer.
1. **buddy**. Выполняет production-сборку и запускает Bundle Buddy.
1. **stats**. Выполняет production-сборку и генерирует stats.json.
1. **static**. Запускает статический сервер для тестирования production-сборки.
1. **jsdoc**. Генерирует документацию JSDoc.
1. **eslint**. Запускает линтинг js-файлов с автофиксом через Prettier.
1. **stylelint**. Запускает линтинг css-файлов с автофиксом через Prettier.
1. **clear-cache**. Удаляет папку с кэшем в node_modules.
1. **rebuild**. Полная пересборка production с предварительной очисткой кэша и генерацией документации.

## Типы сборок

В проекте идёт разделение на **development** и **production** сборку.

**Development-сборка** предназначена для разработки. Эта сборка нацелена на скорость и удобство работы для разработчика. dev-сборка запускает webpack-dev-server (WDS) - виртуальный сервер, на котором хранятся результаты сборки. Доступ к серверу осуществляется через localhost:3000. Для удобства отладки сборки результат копируется на диск в директорию dist. Эта папка не попадает в репозиторий и представлена только для наглядности. WDS наблюдает за изменениями в коде и выполняет пересборку при сохранении файлов. Также использование WDS позволяет использовать Hot Module Replacement (HMR) - обновление измёнённой части страницы без её полной перезагрузки. В текущем варианте HMR поддерживается только для стилей. Для скриптов выполняется полная перезагрузка страницы, а для шаблонов страницу нужно перезагружать вручную. В перспективе использование React позволит использовать HMR на уровне скриптов и шаблонов, но пока что так. development-сборка не предназначена для кроссбраузерного тестирования и аудитов оптимизации, т.к. она работает только в последних версиях Хрома, а вся оптимизация из неё исключена.

**Production-сборка** предназначена для генерации конечного результата frontend-части. Она включает всевозможные работы по оптимизации и может занимать приличное время, т.к. здесь важен исключительно конечный результат. Результаты этой сборки хранятся в папке public, которая передаётся в репозиторий и загружается на сервер. Именно эту сборку следует тестировать на оптимизацию и кроссбраузерность. Для проверки результатов сборки локально используется статический сервер через **yarn static**, который делает доступным содержимое public с localhost:8080. Также этот сервер доступен для тестирования с девайсов, подключённых к сети, через ваш IP (ipconfig).

## Запуск сборок

Для оптимизации времени сборки на проекте идёт кэширование результатов выполнения ряда тяжеловесных лоадеров, плагинов и инструментов. Данные кэша хранятся в папке node_modules/.cache. Такой подход даёт серьёзный выигрыш по скорости, но как это часто бывает с кэшем - он может инвалидироваться и выдавать некорректные результаты (ошибки в сборке, например UglifyJS). Таких случаев минимум, но если они возникают, то просто очищаем кэш через команду **yarn clear-cache**. Первая сборка после очистки будет долгой, а потом всё снова придёт в норму.

Из-за использования механизма кэширования при повторной сборке папки dist/public не удаляются, а идёт только частичная их перезапись. Т.о. при удалении ассета из src он остаётся в папке билда. Это некритично для работы и для dist в частности, но для public, т.к. он попадает в репозиторий, нужно при окончании работы (перед git push) выполнять чистую сборку. Для этого предусмотрен скрипт **yarn rebuild** - эта команда очищает кэш, полностью удаляет public, собирает его заново и обновляет документацию. Эта сборка будет дольше обычной, но её нужно делать только один раз.

Инвалидация кэша всегда происходит после установки новых модулей через yarn, так что скрипт очистки кэша прописан в postinstall, т.е. выполняется автоматически после завершения yarn install. Так что имейте в виду, что первая сборка после этого будет "холодной".

## Конфиг сборки

Проект построен на сборщике Webpack. Точкой входа для него служит файл webpack.config.babel.js. Внутри него прописаны общие настройки, которые распространяются и на dev и на prod сборку. В этот конфиг передаются переменные окружения mode и presets, и в зависимости от их значений объект с общими настройками расширяется параметрами соответствующей сборки и пресетами, если они есть.

Все остальные файлы, относящиеся к сборщику, лежат в директории config. Её содержимое:

1. **webpack.dev.babel.js**. Конфиг development-сборки.
1. **webpack.prod.babel.js**. Конфиг production-сборки.
1. **helpers**. Небольшие вспомогательные функции, используемые в файлах конфига.
1. **presets**. Пресеты. Микроконфиги, которыми можно расширять основные сборки, не затрагивая core-логики.

## Аналитика

Webpack генерирует бандлы и позволяет использовать ряд инструментов для их анализирования. В сборщик встроен **Webpack Bundle Analyzer** - инструмент, запускаемый через команду **yarn analyze** и позволяющий увидеть содержимое ваших бандлов. С помощью него можно узнать какие фрагменты кода куда попадают, какие библиотеки занимают большую часть места и прикинуть как это всё можно оптимизировать.

Также в сборщик встроен **Bundle Buddy** - инструмент, позволяющий анализировать дублирование кода между генерируемыми бандлами. Запускается через **yarn buddy**.

Помимо этого существует множество внешних инструментов, которые позволяют производить аналитику. Все они работают с файлом stats.json, который можно сгенерировать, выполнив команду **yarn stats**.

Примеры таких инструментов:

1. [Webpack Analyse](http://webpack.github.io/analyse/). Официальный инструмент от Webpack, рисующий граф, и выводящий всякого рода информацию по бандлу, и предлагающий ряд улучшений.
1. [Webpack Visualizer](https://chrisbateman.github.io/webpack-visualizer/). Рисует цветастую диаграмму с разбиением на подключаемые модули.
1. [Webpack Chart](https://alexkuz.github.io/webpack-chart/). Альтернативный сервис для построения диаграмм.

## Линтинг и форматирование

Для линтинга JS используется [ESLint](https://eslint.org/). Конфиг для него прописан в .eslintrc.js. В качестве основы берётся [стайлгайд AirBnB](https://github.com/airbnb/javascript) и далее расширяется.

Для линтинга CSS используется [Stylelint](https://stylelint.io/). Конфиг для него прописан в .stylelintrc.js. В качестве основы также берётся [стайлгайд AirBnB](https://github.com/airbnb/css).

Чтобы комфортно работать с проектом и не зарываться в исправление ошибок линтера, на проект подключен форматтер [Prettier](https://prettier.io/). Его главная фишка - это его субъективность. Он позволяет определить только небольшой список глобальных настроек вроде длины строки и числа пробелов табуляции - конфиг прописан в .prettierrc.js, а всё остальное оставляет на своё усмотрение. Такой подход позволяет навсегда оставить споры о стилистическом оформлении кода, т.к. форматтер решает все подобные разногласия за нас, а его широкая популярность делает наш js-код похожим на другой js-код. Т.о. Prettier исправляет все стилистические проблемы, исправление которых можно автоматизировать, а остающиеся проблемы, требующие участия разработчика, правятся вручную.

Prettier интегрирован в качестве форматтера для линтеров, так что запускается не напрямую, а через команды --fix линтеров. Для ручного запуска можно использовать команды **yarn eslint** и **yarn stylelint**.

Встроенный механизм хуков не позволяет закоммитить код, на который ругается линтер. Хуки добавляются на проект через [husky](https://github.com/typicode/husky). На прекоммит прописан запуск [lint-staged](https://github.com/okonet/lint-staged), который запускает линтеры только для файлов, попавших в стейдж, т.е. изменённых в текущем коммите. Эти настройки прописаны в package.json в полях husky и lint-staged.

Можно обходиться npm-скриптами для запуска форматтеров, но гораздо удобнее встроить его себе в редактор, чтобы форматирование запускалось на сейв. Для этой цели большинство редакторов кода и IDE имеют плагины для Prettier. Также рекомендуется поставить плагины для линтеров, чтобы ошибки визуально выделялись прямо в редакторе.

### Интеграция для VSCode

Если вы счастливый обладатель VSCode, то гайд специально для вас.

Устанавливаете следующие расширения:

1. [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
1. [stylelint](https://marketplace.visualstudio.com/items?itemName=shinnn.stylelint)
1. [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)

И прописываете глобальные настройки (Global Settings):

```json
// Включаем форматирование через Prettier на сейв
"editor.formatOnSave": true,
// Но выключаем его для .hbs, т.к. он плохо работает
"[handlebars]": {
    "editor.formatOnSave": false
}
// Включаем форматирование ESLint, не попадающее под Prettier (например, для плагина JSDoc)
"eslint.autoFixOnSave": true,
// Показываем, что используется yarn вместо npm
"eslint.packageManager": "yarn",
// Отключаем все встроенные валидаторы, т.к. этим будет заниматься линтер
"javascript.validate.enable": false,
"typescript.validate.enable": false,
"less.validate": false,
"scss.validate": false,
"css.validate": false,
"postcss.validate": false,
// Активируем Prettier только на проектах, на которых в корне лежит конфиг
"prettier.requireConfig": true,
// Дублируем настройки конфига, чтобы не возникало разночтений
"prettier.singleQuote": true,
"prettier.tabWidth": 4,
"prettier.trailingComma": "es5",
"prettier.printWidth": 120,
```

На старых проектах, где линтеры на уровне проектов не встроены, Prettier отключится автоматически из-за настройки requireConfig, а линтеры нужно отключить вручную на уровне проекта (Workspace Settings):

```json
"eslint.enable": false,
"stylelint.enable": false,
```

## JSDoc

На проекте идёт документирование кода через [JSDoc](http://usejsdoc.org/). Линтер требует, чтобы аннотации присутствовали у функций, методов и классов. Также рекомендуется документировать поля классов и использовать typedef. Подобный строгий подход к документации даёт много профита:

1. Упрощает сопровождение кода.
1. Улучшает синтаксическую подсветку/саджесты со стороны редактора (Intellisense).
1. Позволяет генерировать автоматические доки.

Касательно генерации документации, настройки прописаны в jsdoc.json. Документация генерируется в директории docs и доступна для открытия напрямую через проводник (index.html), либо через dev-сервер (localhost:3000/docs/). Доки генерируются при запуске финальной production-сборки через **yarn rebuild**, либо могут быть созданы напрямую через **yarn jsdoc**.

## Browserslist

[Browserslist](https://github.com/browserslist/browserslist) - это инструмент, позволяющий хранить список поддерживаемых браузеров в едином месте. Ряд инструментов, завязанных на списке браузеров, знают о его существовании и берут конфиг из него. На этом проекте конфиг хранится в package.json в поле browserslist.

Инструменты, использующие Browserslist:

1. **babel**. Транспайлинг ES6+ синтаксиса через @babel/preset-env и подгрузка полифиллов через babel-polyfill.
1. **postcss-preset-env**. Прописывает фоллбеки для браузеров, неподдерживающих современные возможности CSS.
1. **autoprefixer**. Генерация vendor-префиксов.
1. **postcss-normalize**. Кроссбраузерное приведение базовых тегов к единому стилю.

Список браузеров разделяется на development и production. В production прописываются все браузеры, которые должен поддерживать проект на уровне ТЗ, так что стоит актуализировать его на этапе разворота проекта. В development - только те браузеры, в которых работает разработчик (последние версии Хрома + свои по усмотрению).

## Babel

Проект написан на ES6+ синтаксисе. Транспайлинг осуществляет Babel, его настройки прописаны в babel.config.js. Для автоматической поддержки всех современных возможностей используется пресет @babel/preset-env. Экспериментальный синтаксис подключается отдельно через плагины.

Также подключен babel-polyfill, автоматически подгружающий полифиллы для используемого в коде функционала, который невозможно просто затранспайлить.

И пресет и полифилл зависят от Browserslist, так что подтягивают только необходимый код. Более того, опция useBuiltIns: 'usage' позволяет подгружать полифиллы только для тех возможностей, которые непосредственно использованы в коде.

## PostCSS

Стили пишутся на ванильном CSS без препроцессоров, но обрабатываются через PostCSS на наше усмотрение, что открывает широкие возможности по конфигурации. Конфиг прописан в .postcssrc.js.

Основная фишка текущего конфига - это использование postcss-preset-env. Этот плагин позволяет использовать современные возможности CSS уже сейчас, например, CSS-переменные. Такой подход значительно лучше, чем использование того же SASS, т.к. возможности препроцессоров - фиксированные и нестандартные. Использование же возможностей, которые потенциально со временем войдут в стандарт, позволяет, во-первых, быть в тренде и заранее подготовиться (когда они будут поддерживаться по умолчанию, просто уберём эмулирующие их плагины), и, во-вторых, т.к. над ними ведётся активная работа со стороны W3C, они со временем становятся всё комплекснее, а не подвисают в состоянии стагнации, как функции препроцессоров.
