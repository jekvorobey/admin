# Фронтенд

## Сборка

Для сборки используется вебпак.  
Весь фронт лежит в папке *html*. Собирается командами *yarn prod* и yarn *dev-build*.  
Прод сборка кладётся в *public/assets*. Дев сборка кладётся в *html/build*.  

### Переключение dev/prod сборки

Пока механизм не разработан, но в целом предполагается сделать симлинк
```
public/build -> html/build
```
И в зависимости от значения какой-нибудь куки, в шаблоне менять путь подключения скрипта.

## Работа с VueJs

Используется подход описанный в статье https://reinink.ca/articles/server-side-apps-with-client-side-rendering  
Коротко: 

* Никакого рендеринга на стороне сервера, роут генерирует пустую страницу с одним *div#app* которому в одном атрибуте передаётся название компонента, а в другом - json со всеми данными для текущей страницы
* Для каждой страницы делается vue компонент, который получает все данные через *props*
* SEO будет обеспечиваться дополнительным сервисом пререндеринга

Однако в статье не описано как организовать *layout* - т.е. одинаковую для всех страниц разметку.  
Для этого есть папка *components/layout*. В ней лежат компоненты со слотом.  
При создании компонента страницы, всё его содержимое надо обернуть в компонент layout и передать в layout данные для его отрисовки.  

## Совместная работа бэкенда и фронтенда

Предполагается, что фронтенд будет делать отдельные hbs страницы, на каждой из которых подключается фронтенд вариант vue компонента этой страницы.  
В этом компоненте подключается файл стилей для этой страницы, в нём разметка страницы и какая-то базовая логика, чтобы показать динамику.  
Бэкенд, будет копировать эти компоненты и переделывать на работу с реальными данными.  
При этом компоненты, по размеру меньшие чем страницы могут быть как фронтед-бэкендерскими, так и общими, в случае если это элемент управления без какой-то сложной логики.  

Фронтенд варианты компонентов располагаются в папке *static-vue*. Структура этой папки отчасти напоминает структуру папки *vue* - в корне лежит *app.js* и есть папки *pages* и *components*.  
В файле templates/partials/page.hbs подключается бандл фронтенда.  
В файлах pages/<name>/<name>.hbs есть всего одна строчка  
```
<div id="app" data-component="Example"></div>
```
Это точка монтирования компонента на страницу. Здесь указывается какой именно компонент монтируется. В данном случае компонент Example.

## Организация папок

* build (аналогично для assets) - результаты dev сборки + статичные страницы
  * scripts - содержит собранные js скрипты
  * styles - собранные стили
* config - файлы вебпак-конфига
* src - все исходники фронта
  * blocks - hbs шаблоны отдельных блоков (возможно стоит удалить и перейти на vue компоненты)
  * images - картинки
  * pages - hbs шаблоны статических страниц
  * scripts - js скрипты
  * static-vue - vue приложение и компоненты для страниц фронтенда
    * components
      * layout - фронтенд варианты компонентов layout
    * pages - фронтенд варианты компонентов страниц
    * static-app.js точка входа в vue приложение, одна для всех страниц
  * styles - стили
  * templates - более крупные чем блоки hbs шаблоны частей страниц
  * vue
    * components - компоненты (не страницы)
    * pages - компоненты-страницы
    * app.js - точка входа в vue приложение, одна для всех страниц

# Бэкэнд

## Рендеринг данных через vue

Используется подход описанный в статье https://reinink.ca/articles/server-side-apps-with-client-side-rendering

Коротко:

* На сервере ничего не рендерится
* Каждый роут отдаёт пустую страницу, на которой только подключение ассетов и один *div#app* с параметрами подключения vue компонента
* Все данные для отрисовки страницы сериализуются в json и отдаются на клиент

В коде роута это выглядит так:

```php
return View::component('component-name', [
    'component-prop1' => //...,
    'component-prop2' => //...,
]);
```

В фасаде *View* создан макрос *component(name, data)*, который рендерит файл *app.blade.php*.
Пока что передача данных в layout сделана так, позже надо будет добавить какой-то автоматический подтягиватель этих данных.